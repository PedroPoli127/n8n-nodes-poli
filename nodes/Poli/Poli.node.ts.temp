import {  IExecuteFunctions,  INodeExecutionData,  INodeType,  INodeTypeDescription,  JsonObject,  NodeConnectionType,} from 'n8n-workflow';import { NodeApiError } from 'n8n-workflow';import { apiRequest } from './transport';export class Poli implements INodeType {  description: INodeTypeDescription = {    // ...existing code...  };  async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {    const items = this.getInputData();    const returnData: INodeExecutionData[] = [];    for (let i = 0; i < items.length; i++) {      try {        const resource = this.getNodeParameter('resource', i) as string;        const operation = this.getNodeParameter('operation', i) as string;        let responseData;        if (resource === 'channel' && operation === 'listChannels') {          const customerId = this.getNodeParameter('customerId', i);          responseData = await apiRequest.call(this, 'GET', `/accounts/${customerId}/account-channels/?include=*`);        }         else if (resource === 'contact' && operation === 'listContacts') {          const accountId = this.getNodeParameter('accountId', i);          const includeFields = this.getNodeParameter('contactInclude', i) as string[];          const includeParam = includeFields.join(',');          responseData = await apiRequest.call(this, 'GET', `/accounts/${accountId}/contacts?include=${includeParam}`);        }         else if (resource === 'message' && operation === 'sendMessage') {          const accountId = this.getNodeParameter('accountIdMessage', i);          const phoneNumber = this.getNodeParameter('phoneNumber', i);          const accountChannelUuid = this.getNodeParameter('accountChannelUuid', i);          const text = this.getNodeParameter('text', i);          const body = {            provider: 'WHATSAPP',            account_channel_uuid: accountChannelUuid,            type: 'TEXT',            version: 'v3',            components: { body: { text } },          };          const endpoint = `/accounts/${accountId}/contacts/${encodeURIComponent(phoneNumber?.toString() || '')}/messages?include=contact`;          responseData = await apiRequest.call(this, 'POST', endpoint, body);        }        else if (resource === 'message' && operation === 'sendMessageByContactId') {          const contactId = this.getNodeParameter('contactId', i);          const accountChannelUuid = this.getNodeParameter('accountChannelUuid', i);          const text = this.getNodeParameter('text', i);          const body = {            provider: 'WHATSAPP',            account_channel_uuid: accountChannelUuid,            type: 'TEXT',            version: 'v3',            direction: 'OUT',            components: { body: { text } },          };          const endpoint = `/contacts/${contactId}/messages`;          responseData = await apiRequest.call(this, 'POST', endpoint, body);        }        else if (resource === 'template' && operation === 'sendTemplateByContactId') {          const contactId = this.getNodeParameter('contactId', i);          const accountChannelUuid = this.getNodeParameter('accountChannelUuid', i);          const templateUuid = this.getNodeParameter('templateUuid', i);          const headerParams = this.getNodeParameter('headerParams.parameter', i, []) as any[];          const bodyParams = this.getNodeParameter('bodyParams.parameter', i, []) as any[];          const components: any = {};          if (headerParams.length > 0) {            components.header = {              parameters: headerParams.map((param) => ({                type: param.type,                [param.type === 'text' ? 'text' : 'date_time']: param.value,              })),            };          }          if (bodyParams.length > 0) {            components.body = {              parameters: bodyParams.map((param) => ({                type: param.type,                [param.type === 'text' ? 'text' : 'date_time']: param.value,              })),            };          }          const body = {            provider: 'WHATSAPP',            account_channel_uuid: accountChannelUuid,            template_uuid: templateUuid,            type: 'TEMPLATE',            version: 'v3',            components,          };          responseData = await apiRequest.call(this, 'POST', `/contacts/${contactId}/messages`, body);        }        else if (resource === 'template' && operation === 'listTemplates') {          const accountId = this.getNodeParameter('accountIdTemplate', i);          const endpoint = `/accounts/${accountId}/templates?include=key,version,status,message,team,metadata`;          responseData = await apiRequest.call(this, 'GET', endpoint);        }        else if (resource === 'app' && operation === 'createApp') {          const accountId = this.getNodeParameter('accountId', i);          const visibility = this.getNodeParameter('visibility', i) as string;          const appName = this.getNodeParameter('appName', i) as string;          const description = this.getNodeParameter('description', i) as string;          const responsible = this.getNodeParameter('responsible', i) as string;          const phone = this.getNodeParameter('phone', i) as string;          const email = this.getNodeParameter('email', i) as string;          const pictureFileId = this.getNodeParameter('pictureFileId', i, '') as string;          const body = {            visibility: visibility.toUpperCase(),            attributes: {              name: appName,              description,              responsible,              phone,              email,              picture: pictureFileId ? { file_id: pictureFileId } : undefined,            },            attachments: [],            settings: [              {                type: 'link',                name: 'webhook',                placeholder: 'https://example.com/webhook'              }            ],            resources: []          };          const endpoint = `/accounts/${accountId}/applications?include=attributes`;          responseData = await apiRequest.call(this, 'POST', endpoint, body);        }        else if (resource === 'app' && operation === 'listApps') {          const accountId = this.getNodeParameter('accountId', i);          const endpoint = `/accounts/${accountId}/applications?include=attributes`;          responseData = await apiRequest.call(this, 'GET', endpoint);        }        else if (resource === 'webhook' && operation === 'createWebhook') {          const applicationId = this.getNodeParameter('applicationId', i);          const url = this.getNodeParameter('url', i) as string;          const subscriptions = this.getNodeParameter('subscriptions', i) as string[];          try {            new URL(url);          } catch (error) {            throw new Error('URL do webhook inválida. Por favor, forneça uma URL válida.');          }          if (!subscriptions || subscriptions.length === 0) {            throw new Error('É necessário selecionar pelo menos uma subscription.');          }          const validSubscriptions = ['organizations', 'chats', 'contacts', 'users', 'applications'];          const invalidSubscriptions = subscriptions.filter(s => !validSubscriptions.includes(s));          if (invalidSubscriptions.length > 0) {            throw new Error(`Subscriptions inválidas: ${invalidSubscriptions.join(', ')}`);          }          const body = { url, subscriptions };          const endpoint = `/applications/${applicationId}/webhooks?include=url,subscriptions,application`;                    try {            responseData = await apiRequest.call(this, 'POST', endpoint, body);          } catch (error: any) {            if (error.message?.includes('already exists')) {              throw new Error('Já existe um webhook configurado com esta URL para esta aplicação.');            }            throw error;          }        }        else if (resource === 'webhook' && operation === 'listWebhooks') {          const applicationId = this.getNodeParameter('applicationId', i);          const endpoint = `/applications/${applicationId}/webhooks?include=url,subscriptions,application`;          responseData = await apiRequest.call(this, 'GET', endpoint);        }        returnData.push({ json: responseData });      } catch (error) {        throw new NodeApiError(this.getNode(), error as JsonObject, { itemIndex: i });      }    }    return [returnData];  }}